И наконец, компоненты вводятся на панели содержимого.
Несмотря на всю простоту данного примера, демонстрируемый в нем  принцип следует применять при построении любого GUI для Swing-аплета.
Как правило, рисование не выполняется непосредственно на поверхности компонента Swing, тем не менее это можно делать в тех приложениях, где требуется нечто подобное.
Однако имеется ряд очень важных отличий, о которых и пойдет речь в этом разделе.
Подход к рисованию средствами Swing основывается на исходном механизме  из библиотеки AWT, но библиотека Swing позволяет более точно управлять этим  процессом.
Прежде чем приступить к обсуждению особенностей рисования средствами Swing, целесообразно напомнить особенности механизма рисования в библиотеке AWT.
В действительности вызывать этот метод из прикладной программы приходится в очень редких случаях.
Такая ситуация может  возникнуть по нескольким причинам.
Например, окно, в котором отображается  компонент, может быть перекрыто другим окном, а затем появиться снова на экране.
Или же окно может быть свернуто, а затем восстановлено.
Но переопределять его с целью выводить информацию непосредственно на поверхности компонента не придется.
Эти методы рисуют указанную часть компонента,  разделяя процесс рисования на три разных логических действия.
Этот метод отвечает за прорисовку внутренней области компонента.
А два других метода рисования, как правило, переопределять не требуется.
Этого делать не нужно лишь в том случае, если управление отображением компонента осуществляется вручную.
А поскольку  процесс рисования отнимает немало времени, то данный механизм позволяет исполняющей системе мгновенно задерживать рисование до тех пор, пока, например, не завершится выполнение другой задачи, имеющей более высокий приоритет.
Несмотря на то  что любые выводимые данные, выходящие за границы компонента, автоматически отсекаются средствами Swing, вполне возможно, что какой-нибудь рисуемый  участок окажется прямо на границе, а при ее перерисовке он может быть стерт.
Во избежание этого следует вычислить область рисования в пределах компонента.
Эта область определяется следующим образом: из текущих размеров компонента  вычитается пространство, занятое его границами.
Следовательно, прежде чем рисовать на поверхности компонента, следует сначала выяснить ширину границы,  а затем откорректировать соответственно рисование.
Он возвращает объект типа Insets,  содержащий размеры границ  по сторонам компонента.
Объект данного класса служит для отображения линий, конечные точки которых формируются случайным образом.
Размеры панели не  определены, поскольку в данной программе по  умолчанию используется граничная компоновка, а панель вводится по центру.
В итоге панель получает такие размеры, которые позволяют разместить ее по центру.
При изменении размеров окна соответственно подгоняются размеры панели.
Как пояснялось ранее, это требуется для обеспечения надлежащего рисования.
Затем вычисляется ширина и высота панели, а также размеры границ.
Эти значения используются для того, чтобы рисуемые линии не выходили за пределы области рисования на панели.
Область рисования определяется вычитанием размеров границ из общей ширины и высоты компонента.
Чтобы убедиться в этом, попробуйте изменить размеры окна.
Линии по-прежнему  будут рисоваться , не выходя за границы панели.
Всякий раз, когда изменяются размеры окна или же оно сворачивается и восстанавливается, рисуется новый ряд линий.
Но в любом случае линии не будут выходить за пределы  заданной области рисования.
В этой главе продолжается исследование  библиотеки Swing кратким обзором ее компонентов, в том числе кнопок, флажков, деревьев и таблиц.
Компоненты Swing обладают богатыми функциональными  возможностями и допускают специальную настройку в широких пределах.
К сожалению, в рамках данной книги невозможно описать все особенности и свойства  компонентов Swing.
Скорее, цель этого обзора - дать вам представление о возможностях набора компонентов Swing.
Следует также иметь в виду, что в этой главе применение компонентов Swing  демонстрируется на примерах аплетов, поскольку код аплета более компактный,  чем код настольного приложения.
Однако, данные техники применяются и к аплетам, и к приложениям.
Он создает метку и был представлен в предыдущей главе.
Здесь параметр выравнивание определяет вид  выравнивания текста и/или значка по горизонтали в пределах метки.
Предоставить изображение можно несколькими способами, включая чтение изображения из файла или его загрузку по указанному URL.
В приведенном ниже примере аплета демонстрируется порядок создания  и отображения метки, состоящей из значка и символьной строки.
Сначала создается объекта типа ImageIcon для отображения песочных часов  из файла изображения hourglass.
И наконец, созданная метка вводится на панели содержимого.
Как правило, эти события не  нужно обрабатывать в прикладной программе.
Вместо этого достаточно получить  символьную строку, находящуюся в данный момент в текстовом поле.
Когда пользователь  нажимает клавишу <Enter>, наступает соответствующее событие действия.
В результате обработки этого события отображается текст в окне состояния.
Таким образом,  у кнопок имеются общие характерные черты.
С их помощью можно, например, определить различные значки, которые будут отображаться на месте кнопки, когда она отключена, нажата  или выбрана.
Другой значок можно использовать для динамической подстановки,  чтобы он отображался при наведении указателя мыши на кнопку.
Модель, используемая всеми кнопками, определена интерфейсом ButtonModel.
Кнопка генерирует событие действия, когда ее нажимает пользователь.
Возможны и другие события.
В последующих разделах будут подробнее рассмотрены классы отдельных кнопок.
Простая форма конструктора этого класса была представлена в предыдущей  главе.
По умолчанию эта символьная строка отображается в пределах кнопки.
Так, если в одном приложении используются две кнопки или больше, команда действия позволяет легко определить, какая именно кнопка была нажата.
В предыдущей главе был представлен пример применения текстовой кнопки.
А в приведенном ниже примере демонстрируется кнопка в виде значка.
Оно отображает четыре экранные кнопки и одна метка.
Когда пользователь щелкает на кнопке, в метке появляется название часов.
Эта кнопка похожа на обычную кнопку, но действует иначе, поскольку может находиться  в двух состояниях: нажатом и отпущенном.
После щелчка на переключателе он  остается нажатым, а не отпускается, как обычная экранная кнопка.
Если после этого щелкнуть на переключателе еще раз, он отпускается.
Таким образом, всякий  раз, когда пользователь щелкает на переключателе, он переходит в одно из двух возможных состояний.
Стандартным является отпущенное состояние переключателя.
Остальные конструкторы данного класса позволяют создавать переключатели с изображением или текстом надписи и изображением.
Как правило, обращаться непосредственно к этой модели не требуется,  чтобы воспользоваться стандартным переключателем.
Это событие используется теми компонентами, которые  действуют по принципу выбора.
Если пользователь отпускает переключатель, выбор отменяется.
Здесь приведен пример, в котором используется переключатель.
Обратите внимание на то, как работает приемник событий.
Остальные конструкторы позволяют определить исходное состояние выбора флажка и указать значок.
В приведенном ниже примере демонстрируется применение флажков.
В нем отображаются четыре флажка и метка.
Когда пользователь  щелкает кнопкой мыши на флажке, наступает событие типа ItemEvent.
Остальные  конструкторы позволяют определить исходное состояние кнопки-переключателя  и указать для нее значок.
Чтобы активировать их взаимоисключающую природу, переключатели должны быть сконфигурированы в группу.
Можно выбрать только одну кнопку за раз.
Так, если пользователь выбирает какую-нибудь кнопку-переключатель из группы, то кнопка-переключатель, выбранная ранее в этой группе, автоматически выключается.
С этой целью вызывается его конструктор по умолчанию.
В  этом методе можно несколькими способами выяснить, какая именно кнопка-переключатель была выбрана.
И наконец, для каждой кнопки можно вызвать свой обработчик событий действия, реализуемый в виде анонимного класса или лямбда-выражения.
Не следует, однако, забывать, что всякий раз, когда наступает событие действия,  оно означает, что выбранная кнопка-переключатель была изменена и что была выбрана одна и только одна кнопка-переключатель.
В приведенном ниже примере демонстрируется применение кнопок-переключателей.
Создаются три кнопки-переключателя.
Затем кнопки добавлются в группу кнопок.
Как пояснялось ранее, это требуется для того, чтобы они действовали,  взаимно исключая друг друга.
Он управляет рядом компонентов, связывая их с помощью вкладок.
При выборе вкладки связанный с ней  компонент выступает на передний план.
Панели с вкладками широко применяются в GUI современных приложений, и вам, без сомнения, придется не раз употреблять их в своих прикладных программах.
Несмотря на сложную структуру панели  с вкладками, создавать и пользоваться ею очень просто.
Используется конструктор по умолчанию, создающий пустой элемент управления с вкладками, располагаемыми вдоль верхнего края панели.
Два других конструктора позволяют определить расположение вкладок вдоль одной из четырех  сторон окна.
Благодаря этому  вкладка может содержать ряд компонентов.
Добавить панель с вкладками на панель содержимого.
В приведенном ниже примере демонстрируется панель с вкладками.
Каждая кнопка отображает название города.
Каждый флажок отображает название  цвета.
Пользователь может выбрать один из трех ароматов.
Но в любом случае прокручиваемый компонент дополняется горизонтальной и/или вертикальной полосой  прокрутки, если он больше области просмотра, что позволяет прокручивать компонент в пределах панели.
Просматриваемая область панели с полосами прокрутки называется окном просмотра.
Это окно, в котором отображается прокручиваемый компонент.
Таким  образом, в окне просмотра будет показана видимая часть прокручиваемого компонента.
Полосы прокрутки служат для прокручивания компонента в окне просмотра.
Так, если компонент оказывается больше  по высоте, чем окно просмотра, то оно дополняется вертикальной полосой прокрутки.
А если компонент полностью размещается в окне просмотра, то полосы  прокрутки исключаются.
Полосы прокрутки автоматически отображаются, если содержимое панели превышает размеры окна просмотра.
Создать прокручиваемый компонент.
Ввести панель с полосами прокрутки на панели содержимого.
В приведенном ниже примере демонстрируется применение панели с полосами прокрутки.
Далее эта панель вводится на панели с полосами прокрутки, а последняя - на панели содержимого.
Эта панель оказывается больше окна просмотра, поэтому она автоматически дополняется вертикальной и горизонтальной полосами прокрутки.
Полосы прокрутки служат для прокручивания кнопок в окне просмотра.
В этом классе  поддерживается выбор одного или нескольких элементов из списка.
Зачастую список состоит из символьных строк, но ничто не мешает составить список из любых  объектов, которые только можно отобразить.
Этот интерфейс устанавливает порядок доступа к данным в списке.
Благодаря этому длинные списки становятся автоматически прокручиваемыми, что упрощает дизайн GUI.
Это событие наступает и в том случае, если пользователь отменяет выбор элемента.
Если же задан режим выбора  в одном интервале,  то выбрать можно  только один ряд элементов из списка.
Разумеется, один элемент можно выбрать и в двух других режимах.
Эти режимы позволяют также выбирать несколько элементов из списка.
Так, если выбран первый элемент, метод возвращает нулевое значение.
А если не выбрано ни одного элемента, то возвращается значение -1.
Если не выбрано ни одного значения, то возвращается пустое значение null.
В приведенном ниже примере аплета демонстрируется применение простого компонента типа JList ,  содержащего список городов.
Этот метод получает индекс выбранного элемента и отображает имя выбранного города на месте метки.
Как правило, комбинированный список отображает одну запись,  но он может отображать и раскрывающийся список, позволяющий выбирать другие элементы.
Имеется также возможность создать комбинированный список, позволяющий вводить выбираемый элемент в текстовом поле.
Имеются и другие конструкторы.
Этот метод должен использоваться только с изменяемыми комбинированными списками.
Таким образом, при изменении выбора  происходят два события: одно - от того элемента, выбор которого был отменен,  другое - от выбранного элемента.
Нередко оказывается достаточно принимать события действия, но обрабатывать можно оба типа событий.
В приведенном ниже примере демонстрируется применение комбинированного списка.
Если пользователь выберет часы, метка обновится.
Обратите внимание, как мало  кода требуется, чтобы воспользоваться этим сложным компонентом.
В нем предоставляется ряд методов и конструкторов.
Он возвращает символьную строку, описывающую путь.
В частности, можно получить ссылку на родительский узел или список  порожденных им узлов.
В нем объявляются методы, позволяющие вводить и удалять порожденные узлы или изменять родительский узел дерева.
Он  представляет узел дерева.
У нового узла дерева отсутствует родительский или порожденный узел.
Таким образом, большое дерево можно прокрутить в окне просмотра меньших размеров.
Ввести дерево на панели с полосами прокрутки.
Ввести панель с полосами прокрутки на панели содержимого.
Следующий пример показывает, как создать дерево и обработать выбор элементов.
Это самый верхний узел в иерархии дерева.
Получаемая в итоге панель с полосами прокрутки вводится на панели содержимого.
Затем создается и вводится метка на панели  содержимого.
Эта метка отображает выбор узла в дереве.
Чтобы изменить размеры столбцов, достаточно перетащить их границы мышью.
Кроме того, весь столбец можно перетащить в другое место.
В зависимости от конфигурации можно выбрать символьную строку, столбец или  ячейку в таблице, а также изменить данные в ячейке.
Этот компонент состоит из  одного или  нескольких столбцов с данными.
Вверху каждого столбца находится заголовок.
Кроме описания данных в столбце, заголовок предоставляет механизм, с помощью которого пользователь может изменять размеры столбца или его местоположение в таблице.
Эта модель определяет все, что связано с отображением данных в двухмерном формате.
Обработка таких событий требует больших затрат труда, чем обработка событий в описанных ранее  компонентах, а ее рассмотрение выходит за рамки данной книги.
Вывести таблицу на панели с полосами прокрутки.
Вывести панель с полосами прокрутки на панели содержимого.
В приведенном ниже примере демонстрируется создание и применение простой таблицы.
Создан двумерный массив символьных строк data для данных в ячейках таблицы.
Каждый элемент массива data является массивом из трех символьных строк.
Таблица вводится на панели с полосами прокрутки,  а та - на панели содержимого.
В таблице отображаются данные из массива data.
Стандартная конфигурация таблицы позволяет также редактировать содержимое  ячеек.
Все вносимые в них изменения отражаются на содержимом базового массива data.
Меню являются неотъемлемой частью многих  приложений, поскольку они представляют пользователю функциональные возможности прикладной программы.
В силу своего особого значения меню нашли  широкую поддержку в библиотеке Swing.
Именно в меню проявляется истинный  потенциал библиотеки Swing.
Строка меню, отображающая главное меню прикладной программы.
Стандартное меню, которое может содержать выбираемые пункты или другие меню, иначе называемые подменю.
Всплывающее или контекстное меню, которое обычно активизируется  щелчком правой кнопкой мыши.
Панель инструментов, предоставляющая быстрый доступ к функциональным возможностям прикладной программы (зачастую параллельно с пунктами меню).
Действие, позволяющее одному объекту управлять разными (двумя или  больше) компонентами.
Меню в Swing поддерживают также оперативные клавиши, позволяющие быстро выбирать пункты, не активизируя само меню, а также мнемонику для выбора  пунктов меню нажатием клавиш после отображения самого меню.
На первый взгляд, они могут привести в некоторое замешательство, но на самом деле пользоваться меню в Swing очень просто.
Swing допускает специальную настройку, если таковая требуется, в самых широких пределах, но  как правило, классы меню применяются в без изменений, поскольку они поддерживают все необходимые варианты построения меню.
Например, в меню совсем  не трудно ввести изображения и клавиатурные сокращения.
Проще говоря, этот класс служит контейнером для меню.
Помимо меню, раскрывающихся из строки меню, можно создавать автономные всплывающие меню.
Как правило, всплывающее (или контекстное) меню активизируется щелчком  правой кнопкой мыши, когда курсор находится на том компоненте, для которого  определено всплывающее меню.
В меню можно вводить не только стандартные пункты, но и пункты, отмечаемые  флажками или кнопками-переключателями.
Их можно применять в стандартных  и всплывающих меню.
Такой компонент нередко служит для быстрого доступа к функциональным возможностям, имеющимся в меню приложения.
Например, панель инструментов может предоставлять быстрый доступ к командам форматирования, которые поддерживаются в текстовом редакторе.
Следовательно, все пункты меню, по существу, являются кнопками.
Очевидно, что пункты не похожи  внешне на кнопки, когда выбираются из меню, но они действуют, главным образом, как кнопки.
Так, если выбрать пункт меню, то событие действия будет сгенерировано таким же образом, как и при нажатии экранной кнопки.
Это дает возможность создавать подменю, т.е. одни меню, вложенные  в другие.
Этот процесс демонстрируется в следующем разделе.
Как упоминалось выше, при выборе пункта меню генерируется событие действия.
Символьная строка с командой действия, связанная с этим событием действия,  по умолчанию обозначает наименование выбранного пункта меню.
Безусловно, для обработки событий действия от каждого пункта меню можно воспользоваться отдельными анонимными классами или лямбда-выражениями.
В этом случае выбранный пункт меню уже известен, и поэтому нет нужды анализировать команду действия, чтобы выяснить, какой именно пункт меню был выбран.
Меню могут генерировать и другие типы событий.
Но как  правило, отслеживать требуется только события действия, и поэтому в этой главе  рассматривается обработка только этих событий.
Эти классы составляют  тот минимум средств, которые требуются для построения главного меню приложения.
Таким образом, эти классы образуют основание системы меню.
У этого класса имеется  единственный конструктор по умолчанию.
Следовательно, строка меню первоначально будет пустой, и поэтому ее придется наполнить меню, прежде чем ею воспользоваться.
У каждого приложения имеется одна и только одна строка меню.
Возвращается ссылка на меню.
Меню располагаются в строке меню слева направо в том порядке, в каком  они вводятся.
Индексирование начинается с нуля, причем нулевой индекс обозначает  крайнее слева меню в строке меню.
Иногда из строки меню требуется удалить меню, которое больше не нужно.
Индексация меню начинается с нуля.
Строка меню отображается на позиции, определяемой стилем оформления GUI.
Как правило, оно располагается в вдоль верхнего края окна приложения.
Следовательно, одно меню может служить подменю для другого.
Разумеется, присваивать наименование меню совсем не обязательно.
В любом случае создаваемое с их помощью меню будет пустым до тех пор, пока в него не будут введены отдельные пункты.
Здесь вкратце описываются лишь  наиболее употребительные из них.
Первый конструктор добавляет пункт меню в конец меню.
Как  и следовало ожидать, индексирование пунктов меню начинается с нуля.
Обе формы возвращают ссылку на добавленный пункт меню.
Следовательно, когда выбирается пункт меню, генерируется событие действия.
Второй конструктор создает пункт меню, отображающий указанное изображение.
Третий конструктор создает пункт меню, обозначаемый параметром имя и отображающий указанное изображение.
Четвертый конструктор создает пункт  меню, обозначаемый параметром имя и использующий указанную клавиатурную  мнемонику.
Эта мнемоника позволяет выбрать пункт меню нажатием указанной  клавиши.
И последний конструктор создает пункт меню, используя сведения, обозначаемые параметром действие.
Поддерживается также конструктор по умолчанию.
Оно доступно  из строки меню и определяет все (или почти все) функциональные возможности  приложения.
К счастью, библиотека Swing значительно упрощает создание главного меню и управление им.
Ниже будет показано, как создать элементарное главное меню.
Далее будет показано,как ввести в него отдельные варианты выбора.
Процесс создания главного меню состоит из нескольких стадий.
Затем создается каждое меню, располагаемое в строке меню.
Как только отдельные меню будут созданы, они  вводятся в строку меню.
И наконец, каждый пункт меню должен быть дополнен приемником действий, обрабатывающим событие действия, наступающее при выборе отдельного пункта из меню.
Процесс создания меню и управления ими станет понятнее, если продемонстрировать его на конкретном примере.
Ниже приведена программа, в которой  создается простая строка меню, состоящая из трех меню.
Когда выбран пункт меню, его название отображается в метке на панели содержимого.
Этот метод немедленно завершает программу и передает свой аргумент в качестве кода состояния вызывающему  процессу, которым обычно является операционная система или браузер.
Условно  нулевой код состояния означает нормальное завершение программы.
Любой другой код состояния обозначает ненормальное завершение программы.
Отображается результат выбора всех остальных пунктов меню.
Можете попробовать ввести  еще одно меню или дополнительные пункты в уже имеющиеся меню.
Ваша главная  задача - уяснить основные принципы создания меню, поскольку данная программа будет постепенно усложняться по ходу изложения материала этой главы.
Меню реальных прикладных программ обычно поддерживают клавиатурные сокращения, предоставляя опытным пользователям возможность быстро выбирать пункты меню.
Клавиатурные сокращения принимают две  формы: мнемонику и оперативные клавиши.
Применительно к меню мнемоника  определяет клавишу, нажатием которой выбирается отдельный пункт активного  меню.
Следовательно, мнемоника позволяет выбирать с клавиатуры пункты того  меню, которое уже отображается.
Оперативная клавиша-это клавиша, позволяющая выбрать пункт меню без необходимости его предварительной активации.
В первой форме этот символ указывается в виде значения типа  char.
В качестве параметра модификатор следует указать значение одной или нескольких констант, перечисленных ниже и определяемых в java.
Второй конструктор создает пункт меню, обозначаемый параметром имя  и отображающий указанное изображение.
Как правило, такой значок отображается светло-серым цветом,  когда пункт меню недоступен.
Если неактивный значок указан, то он отображается  при условии,  что пункт меню недоступен.
Всплывающая подсказка- это небольшое сообщение, кратко описывающее пункт  меню.
Она автоматически отображается, когда курсор задерживается на компоненте на какое-то малое время.
Это означает, что всплывающую подсказку можно ввести  и в другие типы компонентов, в том числе и экранные кнопки.
Попробуйте сделать это сами.
Эти отмечаемые пункты меню  упрощают построение GUI, делая доступными из меню такие функциональные  возможности, для предоставления которых в противном случае потребовались бы  дополнительные автономные компоненты.
Кроме того, наличие флажков и кнопок-переключателей в меню иногда кажется вполне естественным для выбора конкретного ряда средств.
Но независимо от конкретных причин для применения  флажков и кнопок-переключателей в меню библиотека Swing позволяет сделать  это довольно просто, как поясняется ниже.
В нем определяется несколько конструкторов.
Флажок  исходно установлен. 
А иначе - сброшен.
Исходно флажок в данном пункте  меню сброшен.
Предоставляются и другие конструкторы.
Флажки в меню действуют аналогично автономным флажкам.
В частности, они  генерируют события действия и события от элементов при изменении их состояния.
Флажки особенно полезны в тех меню, где требуется отобразить состояние  выбранных или невыбранных пунктов.
Обычно, всплывающее меню активизируется щелчком правой кнопкой мыши при наведении курсра на компонент.
Другой конструктор позволяет определить заголовок меню.
Будет ли отображаться этот заголовок, зависит от выбранного стиля GUI.
Этот класс предоставляет богатый набор конструкторов.
Второй конструктор позволяет указать исходное состояние кнопки-переключателя.
Если параметр принимает значение true,  то кнопка исходно выбрана.
Иначе она не выбрана.
Другие конструкторы позволяют дополнительно указать изображение.
Если параметр состояние принимает логическое значение true,  то кнопка-переключатель исходно выбрана.
Иначе - не выбрана.
Поддерживается несколько других конструкторов.
Как и автономные кнопки-переключатели, в меню кнопки-переключатели должны быть объединены в группу, чтобы они действовали в режиме взаимоисключающего выбора.
Помимо дополнительных возможностей флажков и кнопок-переключателей, отмечаемые пункты меню ничем не отличаются от обычных  пунктов меню.
Как правило, всплывающее меню активизируется щелчком правой кнопкой мыши на компоненте.
А другой конструктор позволяет указать заголовок всплывающего меню.
Отображение этого заголовка зависит от выбранного стиля оформления GUI.
Обработка результатов выбора пунктов всплывающего меню  выполняется тем же самым способом: приемом событий действия.
А отличаются  всплывающие меню от обычных главным образом процессом их активизации.
Процесс активизации всплывающего меню разделяется на три стадии.
Нужно зарегистрировать приемника для событий мыши.
Внутри метода обработки события от мыши вам нужно следить за триггером активизации всплывающего меню.
Рассмотрим каждую из этих стадий подробнее.
Всплывающее меню обычно  активизируется щелчком правой кнопкой мыши, когда курсор находится на том  компоненте, для которого определено всплывающее меню.
Следовательно, запуск  всплывающего меню происходит после щелчка правой кнопкой мыши на компоненте, снабженном всплывающим меню.
В зависимости от выбранного стиля оформления GUI любой из этих двух событий может запустить всплывающее меню.
Они используются для определения координат верхнего  левого угла всплывающего меню, когда оно отображено.
Вы можете использовать этот метод для активизации всплывающего меню.
Всплывающие меню не вводятся ни в строку меню, ни в какой-нибудь другой объект.
Это  означает, что если щелкнуть правой кнопкой мыши в любом месте панели содержимого, то произойдет запуск всплывающего меню.
В данном случае вызывающим компонентом будет панель содержимого.
В итоге левый верхний угол всплывающего меню оказывается в верхнем правом углу прямо под курсором.
И наконец, в данную программу нужно ввести приведенные ниже приемники  действий.
Они обрабатывают события действия, наступающие в тот момент, когда  пользователь выбирает пункт из всплывающего меню.
Такая панель состоит из ряда кнопок (или других компонентов) , предоставляющих пользователю возможность немедленного доступа  к различным параметрам и режимам работы программы.
Например, панель инструментов может содержать кнопки для выбора параметров шрифтового оформления текста, в том числе полужирного или наклонного начертания, выделения  или подчеркивания текста.
Эти параметры можно выбрать, не раскрывая меню.
Как правило, кнопки на панели инструментов обозначены значками, а не текстовыми надписями, хотя допускается и то и другое.
Кроме того, кнопки на панели  инструментов нередко снабжаются значками с всплывающим подсказками.
Конструкторы этого класса позволяют создать панель инструментов  как с заголовком, так и без него.
Вы также указать расположение панели инструментов по горизонтали или по вертикали.
Второй конструктор создает горизонтальную панель с указанным заголовком.
Заголовок отображается только в том случае, когда панель инструментов перемещается за пределы окна.
Третий конструктор создает панель инструментов, расположение которой  определяется параметром ориентация.
И четвертый  конструктор создает панель инструментов с указанным заголовком и расположением, определяемым параметром ориентация.
Как правило, панель инструментов применяется в окне с граничной компоновкой.
Для этого есть две причины.
Во-первых, это позволяет первоначально расположить  панель инструментов вдоль одной из четырех границ окна.
Зачастую она располагается  вдоль верхней границы.
Во-вторых, это позволяет перетаскивать панель инструментов в любую сторону окна.
В дополнение к возможности перетаскивать панель инструментов в любую сторону внутри окна, вы также можете перетащить ее за пределы окна.
В последнем случае панель инструментов оказывается отстыкованной.
Если при создании панели инструментов указать заголовок, то он появится, когда панель будет отстыкована.
Кнопки (или другие компоненты) вводятся на панели инструментов таким же образом, как и в строке меню.
Компоненты  отображаются на панели инструментов в том порядке, в каком они вводятся.
Как только панель инструментов будет создана, ее не следует вводить в строку  меню, если таковая имеется.
Вместо этого ее следует ввести в контейнер окна.
Как  упоминалось выше, панель инструментов обычно вводится вдоль верхней границы (северного расположения в граничной компоновке) с горизонтальной ориентацией.
А затрагиваемый компонент вводится по центру граничной компоновки.
При таком расположении панель инструментов окажется там, где и предполагается ее обнаружить при запуске прикладной программы.
Панель инструментов можно перетаскивать в любое место окна.
Конечно, панель инструментов также можно перетаскивать за пределы окна.
Эта панель состоит из трех режимов отладки: установки точки прерывания, очистки точки прерывания и возобновления выполнения программы.
Для добавления панели инструментов требуется выполнить три стадии.
Рассмотрим подробнее приведенный выше фрагмент кода.
Далее создаются три кнопки для панели инструментов.
Причем у каждой из них имеется свой значок вместо текстовой надписи.
Кроме того, для каждой кнопки явным образом задается  команда действия и всплывающая подсказка.
После этого кнопки вводятся на панели инструментов, а сама панель - на северной стороне граничной компоновки фрейма.
Всякий раз, когда пользователь щелкает на кнопке на панели инструментов, наступает событие действия, которое обрабатывается таким же образом, как  и другие связанные с меню события.
В подобных случаях выбор какого­нибудь варианта (например, установки точки прерывания при отладке) из меню или  панели инструментов вызывает одно и то же действие.
Кроме того, для обозначения  кнопки на панели инструментов и пункта меню используется (чаще всего) один и тот  же значок.
Более того, если кнопка становится недоступной на панели инструментов,  то недоступным оказывается и соответствующий пункт меню.
В подобных случаях  обычно накапливается довольно большой объем дублирующегося взаимосвязанного  кода, что нельзя назвать оптимальным решением.
Правда, библиотека Swing предлагает выход из этого затруднительного положения в виде действий.
Благодаря такому сочетанию одним действием можно управлять двумя или более компонентами.
Например, действие позволяет централизовать управление кнопкой на панели  инструментов и пунктом в меню.
Вместо дублирования кода в прикладной программе нужно лишь создать действие, управляющее обоими компонентами.
Этот метод будет обрабатывать события действия, генерируемые объектами, связанными  с отдельным действием.
Команда  действия указывается в виде символьной строки.
Это значение типа Integer.
Значок указывается в виде объекта типа Icon.
Это описание указывается в виде символьной строки.
Представляет имя действия, которое становится  также именем элемента (кнопки или пункта меню), с которым связано это действие.
Это имя указывается  в виде символьной строки.
Если оно установлено, то элемент выбран.
Состояние представлено логическим значением.
Этот текст указывается в виде  символьной строки.
Этот значок указывается в виде объекта типа Icon.
Иначе, он не активен.
В другом случае, он вернет логическое значение false.
Те действия, которые поддерживают элементы панели инструментов, также будут поддерживать те же элементы в меню.
Поэтому, вместо того, чтобы писать дублирующийся код, обрабытывающий панель инструментов и меню, оба компонента обрабатываются действиями.
Используя эти действия можно создавать пункты подменю.
Таким образом, любое изменение в свойстве действия (например, его запрет) будет оказывать воздействие на все варианты его использования.
Прежде чем завершить, будет полезно составить все части вместе.
Это позволит не только избежать  недоразумений относительно согласованности отдельных частей программы, но  и получить рабочую программу для демонстрации меню и дальнейшего экспериментирования с ними.
Ради  большей ясности эта программа была реорганизована таким образом, чтобы использовать отдельные методы для создания разных меню и панели инструментов.
Она предоставляет немало других средств, которые  вам придется освоить самостоятельно.
Можете также  поэкспериментировать с определением собственной модели для различных компонентов.
Откровенно говоря, самый лучший способ изучения возможностей библиотеки Swing - экспериментировать с ней.
И это относится к его библиотекам.
Характерным  примером такого развития служат библиотеки для построения GUI.
Как пояснялось ранее в данной книге,  первоначально для построения GUI была разработана библиотека AWT.
Но в силу ряда присущих ей ограничений  вскоре была разработана библиотека Swing, предлагавшая более совершенный подход к построению GUI.
Эта библиотека оказалась настолько удачной, что до сих пор  остается основной в Java для построения GUI.
Десять лет - это большой промежуток времени в быстро меняющемся мире программирования!
Тем не менее библиотека Swing была созадана в то время, когда в разработке программного обеспечения господствующее положение занимали корпоративные приложения.
А ныне особое значение приобрели потребительские приложения, особенно для мобильных устройств, и от таких приложений зачастую требуется визуальная  привлекательность.
Более того, наметилась общая тенденция к наделению приложений, независимо от их типа, захватывающими визуальными эффектами.
Поэтому  с учетом этих типов GUI потребовался новый подход, что и привело к разработке библиотеки JavaFX.
JavaFX стала новым поколением клиентских платформ и библиотеки для построения GUI на Java.
JavaFX служит эффективным, рациональным, удобным каркасом для построения современных визуально привлекательных GUI.
Поэтому в этой и двух последующих главах представлены  лишь основные средства и способы построения GUI на основе JavaFX.
Овладев  этими основами, вы сможете без особого труда самостоятельно изучить остальные  особенности JavaFX.
Но, принимая во  внимание немалый объем унаследованного кода на Swing, а также огромную армию специалистов, умеющих разрабатывать приложения на основе библиотеки Swing, она еще нескоро выйдет из употребления.
И это особенно касается корпоративных  приложений.
Тем не менее JavaFX была ясно определена как перспективная платформа.
Ожидается,  что через несколько лет JavaFX полностью вытеснит Swing  для разработки новых проектов.
Поэтому ни один программирующий на Java не  должен игнорировать JavaFX.
Прежде чем продолжить дальше, следует вкратце упомянугь, что разработка  JavaFX происходила в две основные стадии.
Например, JavaFX легковесный.
А также он поддерживает архитектуру MVC.
Большая часть того,  что вам уже известно о построении GUI средствами Swing, пригодится и в JavaFX.
Тем не менее между ними имеются существенные отличия.
Первые отличия JavaFX и Swing, с точки зрения программирования, состоят в организации самого каркаса и взаимосвязи главных его компонентов.
Проще говоря, JavaFX предлагает более рациональный, простой в употреблении и усовершенствованный  подход к построению GUI.
JavaFX также значительно упрощает рендеринг объектов, поскольку он автоматически обрабатывает перерисовку.
Программе больше не нужно решать эту задачу вручную.
Но это совсем не означает, что библиотека Swing разработана неудачно.
Это не так.
Просто искусство программирования заметно продвинулось вперед, и плоды этого прогресса были пожаты в JavaFX.
В целом JavaFX способствует выбору более  динамичного визуально подхода к построению GUI.
В примерах этой главы употребляются лишь некоторые пакеты, поэтому вам придется ознакомиться с функциональными возможностями остальных пакетов JavaFx самостоятельно, а они довольно обширны.
JavaFX предлагает большой набор функциональности.
Как и в настоящей театральной постановке, подмостки содержат сцену.
Проще говоря, подмостки определяют пространство, а сцена - то, что находится в этом пространстве.
Иными словами, подмостки служат контейнером для сцен, а сцена - контейнером  для элементов, которые ее составляют.
Таким образом, все JavaFX-приложения состоят, по крайней мере, из одних подмостков и одной сцены.
Рассмотрим оба эти класса более подробно.
Главные подмостки предоставляются исполняющей системой  при запуске JavaFX-приложения на выполнение.
Для многих приложений требуются лишь одни главные подмостки, хотя можно создать и другие подмостки.
Это могут быть элементы управления, в том числе экранные  кнопки и флажки, а также текст и графика.
Например, узлом считается  элемент управления экранной кнопкой.
Но сами узлы могут состоять из групп других узлов.
У каждого узла может быть потомок.
Более того, узел с потомком называется родительским узлом, или узлом ветвления.
А узлы без потомков  являются концевыми и называются листьями.
Совокупность всех узлов в сцене называется графом, образующим дерево.
В графе сцены имеется специальный тип узла, называемый корневым.
Это самый верхний и единственный узел графа, не имеющий родителя.
Следовательно, все узлы, кроме корневого, имеют родителей, причем все они прямо или  косвенно происходят от корневого узла.
Он служит для выполнения различных инициализаций.
Но, как поясняется далее, с его помощью нельзя создать подмостки или построить сцену.
Если же  инициализация не требуется, то и переопределять этот метод не нужно, поскольку по умолчанию предоставляется его пустой вариант.
Именно с него и начинается  приложение, поскольку он позваляет построить и установить сцену.
Это главные подмостки, предоставляемые исполняющей системой.
Имеется возможность создать и другие подмостки, но для простых приложений  этого не требуется.
Следует заметить, что этот метод является абстрактным.
Он должен быть переопределен в вашем приложении.
Именно в нем  должны быть произведены все операции очистки или закрытия.
Если же такие  операции не требуются, то по умолчанию предоставляется пустой вариант данного метода.
У него имеются две формы.
Тем не менее его включение упрощает процесс тестирования и отладки приложения и позволяет эксплуатировать программу, не прибегая к созданию JAR-файла.
Именно поэтому он включен в примеры всех  JavaFX-приложений,  представленные в данной книге.
Поэтому, прежде чем перейти к рассмотрению каких-нибудь других  средств JavaFX, стоит продемонстрировать скелет JavaFX-приложения.
Помимо  общей формы такого приложения, скелет демонстрирует порядок его запуска  и вызова методов его жизненного цикла.
Когда вызывается каждый метод жизненного цикла, на консоль выводится извещающее об этом сообщение.
Это делается ради того, чтобы показать, когда именно  вызывается каждый метод.
Именно  в нем и создается первоначальная сцена и устанавливаются главные подмостки.
Проанализируем этот метод построчно.
Подмостки приложения , где и устанавливается сцена для приложения.
Указанный заголовок становится заглавием главного окна приложения.
Далее создается корневой узел сцены.
Это единственный узел графа сцены,  у которого отсутствует родитель.
В этой компоновке элементы располагаются построчно с автоматическим переходом на новую строку, если требуется.
Имеется возможность указать и другие свойства компоновки, в том числе промежугки между элементами по горизонтали и по вертикали, а также  выравнивание, хотя в данном скелетном приложении этого не требуется.
Вы увидите пример далее в этой главе.
В той форме, которая применяется здесь и далее, создается сцена  с указанным корневым узлом и заданной шириной и высотой.
А параметры ширина и высота относятся к типу double.
Это дает возможность  передавать дробные числовые значения, если требуется.
К числу самых главных преимуществ JavaFX относится возможность выполнять  одну и ту же прикладную программу в различных исполняющих средах.
В частности, ее можно выполнить как автономное настольное приложение, в окне браузера или же как приложение типа Web Start.
Но иногда прикладной программе могут потребоваться различные вспомогательные файлы, в том числе HTML-файл  или файл формата JNLP (Java Network Launch Protocol) - сетевой протокол запуска  приложений на Java.
Но поскольку ему требуется дополнительная поддержка  для различных исполняющих сред, то его проще всего скомпилировать в интегрированной среде разработки (IDE) , полностью поддерживающей программирование средствами JavaFX, например, в NetBeans.
Для этого достаточно следовать инструкциям в применяемой IDE.
С другой стороны, если требуется скомпилировать и проверить JavaFX­ приложение, используя инструментальные средства в режиме командной строки,  то и это сделать совсем не трудно.
Для этого достаточно скомпилировать и выполнить приложение обычным образом по командам javac и java соответственно.
Следует, однако, иметь в виду, что компилятор, работающий в режиме командной  строки, не создает ни архивный JAR-файл приложения, ни файлы формата HTML  или JNLP, которые могут потребоваться, если приложение необходимо выполнить не как автономное, а как-то иначе.
Также элементы GUI нельзя создать в конструкторе класса приложения.
Потому что подмостки или сцена должны строиться в потоке исполнения приложения.
Следовательно,  их нельзя использовать для построения подмостков или сцены.
Более того, любые изменения в GUI, отображаемом в данный момент, должны производиться из потока исполнения приложения.
Правда, в JavaFX события  посылаются прикладной программе в потоке исполнения приложения.
Поэтому  для взаимодействия с GUI могут быть использованы обработчики событий.
Как и следовало ожидать, в JavaFX предоставляется богатый арсенал элементов управления.
Простейшим элементом управления является метка, поскольку она  только отображает сообщение, например текстовое.
Несмотря на всю свою простоту, метка служит удобным примером для демонстрации приемов, которыми  нужно овладеть, чтобы приступить к построению графа сцены.
Как вам должно быть уже известно, большинство элементов управления GUI генерируют события, обрабатываемые в прикладных программах.
Например, кнопки, флажки  и списки - все эти элементы управления генерируют события, когда ими манипулирует пользователь.
Во многих отношениях обработка событий в JavaFX организуется таким же образом, как и в Swing или AWT, но только она более рационализирована.
Следовательно, если вы приобрели практические навыки обработки событий в GUI, то вам не составит особого труда  овладеть системой обработки событий, предоставляемой в JavaFX.
К числу наиболее употребительных элементов управления относится экранная  кнопка.
Он обрабатывает события, генерируемые экранной кнопкой.
В общем, для обработки событий в JavaFX применяется модель делегирования  событий.
Чтобы обработать событие, нужно сначала зарегистрировать его обработчик, действующий как приемник данного события.
Когда наступает событие,  вызывается его приемник.
Он должен отреагировать на событие и выполнить возврат.
Как правило, обработчики событий реализуются в анонимных внутренних классах или  лямбда-выражениях, но для этой цели подходят и автономные классы, если они  более пригодны для приложения (например, если один обработчик  должен обрабатывать события из нескольких источников).
Иногда полезно знать источник события, хотя в представленных далее примерах этого не требуется.
Это особенно важно, если один обработчик должен  обрабатывать события из разных источников.
Как только событие будет употреблено, его  передача родительскому обработчику прекращается.
И последнее замечание: в JavaFX обработка событий выполняется по цепочке диспечеризации событий.
Когда событие генерируется, оно передается корневому узлу.
Событие затем передается вниз по цепочке адресату события.
После обработки события в узле его адресата оно передается обратно вверх по цепочке, предоставляя  возможность родительским узлам обработать его по мере надобности.
Такой механизм называется всплыванием событий.
Он позволяет  любому узлу цепочки употребить событие, чтобы оно больше не обрабатывалось.
На заметку! В JavaFX-приложении можно также реализовать фильтр событий для управления  ими, хотя эдесь он не рассматривается.
Фильтр может употребить событие,  предотвратив тем самым его дальнейшую обработку.
Кроме того, в этом классе поддерживается большое разнообразие операций.
Но здесь рассматривается его форма, используемая по умолчанию.
В примерах  из этой главы применяются кнопки с текстовой надписью.
Пример кнопки с графикой приводится в следующей главе.
Как упоминалось ранее, для реализации обработчика событий нередко применяется анонимный внутренний класс или лямбда-выражение.
Как и при обработке всех остальных событий в Java, такой обработчик событий должен как можно быстрее реагировать на событие и выполнять  возврат.
Если же обработчик событий делает это слишком медленно, то тем самым  он заметно тормозит работу приложения.
Поэтому для длительных операций следует предусмотреть отдельный поток исполнения.
На нем отображается две кнопки и метка.
Всякий раз, когда нажимается экранная кнопка, на месте метки выводится сообщение, извещающее, какая именно кнопка была нажата.
Это делается  для того, чтобы она была доступна для обработчиков событий от экранных кнопок, реализуемых в виде анонимных внутренних классов.
В данном примере интересно также отметить две особенности отображения  элементов управления в окне приложения.
Они обозначают промежутки между элементами управления, оставляемые в сцене по горизонтали и по вертикали.
Если эти промежутки не указаны, элементы  управления (в данном случае две экранные кнопки) располагаются вплотную друг  к другу.
Следовательно, пользоваться ими будет неудобно, а сам пользовательский  интерфейс приобретет неприглядный вид.
Можно указать и другие стили выравнивания.
Прежде чем продолжить дальше, следует заметить несколько моментов.
В рассматриваемом  здесь примере для обработки событий используются анонимные внутренние  классы.
Как видите, лямбда-выражение выглядит более компактно,  чем анонимный  внутренний класс.
Но в последующих примерах все же применяются анонимные  внутренние классы, поскольку лямбда-выражения внедрены лишь недавно в Java,  тогда как анонимные внутренние классы уже давно нашли широкое применение  и хорошо известны практически всем программирующим на Java.
Это позволяет также компилировать примеры программ, используя версию JDK 7, где лямбда-выражения не поддерживаются.
Однако вы можете сами поэкспериментировать с преобразованием их в лямбда-выражения.
Это хороший способ, чтобы приобрести практические навыки применения лямбда-выражений в своем коде.
В этом состоит одно из главных усовершенствований JavaFX  по сравнению с Swing.
Более того,  в приложении приходится хранить содержимое окна, перерисовывая его по мере  надобности.
Это неудобство устраняется в JavaFX благодаря слежению за тем, что требуется отображать в сцене, и повторному воспроизведению сцены по мере надобности.
Его называют режимом удержания.
Повторное воспроизведение выполняется автоматически.
Когда на холсте  рисуется какой-нибудь графический объект, например линия , он автоматически воспроизводится средствами JavaFX всякий раз, когда требуется воспроизвести  его повторно.
Прежде чем рисовать на холсте, следует выполнить два действия.
Если вы связываете свое будущее с программированием сложной графики, вам определенно следует внимательно изучить возможности этого класса.
В целях демонстрации далее будут использованы  лишь некоторые методы из этого класса, хотя и они дают ясное представления  об его огромном потенциале.
Эти методы описываются далее.
Ширина и высота обозначают его ширину и высоту.
Текущая заливка может быть такой же простой, как сплошной цвет или что-то более сложное.
Параметры ширина и высота обозначают соответствующие размеры холста.
Чтобы нарисовать окружность, следует передать одинаковые значения параметров ширина  и высота.
По умолчанию используется системный шрифт.
В его подклассах определяются конкретные разновидности заливки и обводки.
В приведенном ниже примере приложения демонстрируется рисование  на холсте описанными выше методами.
Сначала в данном приложении воспроизводятся три графических объекта на холсте.
Запустив это  приложение на выполнение, вы обнаружите, что формы, цвет которых не меняется, не оказывают никакого влияния на изменение цвета остальных графических  объектов.
Более того, если попытаться скрыть окно данного приложения , а затем  раскрыть его, содержимое холста будет автоматически перерисовано без участия прикладной программы.
В частности, к графическим объектам можно применять различные эффекты и выполнять над ними преобразования, в том  числе вращение, масштабирование и искажение.
Несмотря на обилие средств,  доступных в этом классе, овладеть ими не так уж и трудно.
Следует также иметь  в виду, что холст прозрачен.
Так, если расположить два холста один за другим, то  видно будет содержимое обоих холстов.
Иногда это может быть полезным.
По ходу их описания были представлены два  элемента управления: метка и кнопка.
В этой главе будет продолжено рассмотрение элементов управления JavaFX.
В начале главы поясняется, каким образом метка  и кнопка снабжаются изображениями.
Затем дается краткий обзор некоторых других элементов управления JavaFX, в том числе флажков, списков и деревьев.
Следует,  однако, иметь в виду, что JavaFX - насыщенный функциональными возможностями  и довольно мощный каркас.
Поэтому основное назначение этой главы - представить наиболее употребительные элементы управления JavaFX и описать некоторые  общие приемы их применения.
Овладев основами, вы сможете без особого труда  самостоятельно изучить остальные элементы управления.
Так, помимо текстовой надписи, метку или кнопку можно снабдить изображением.
Более того, изображения можно встраивать непосредственно в сцену как автономные графические объекты.
Если  этот параметр не состоит из сформированного надлежащим образом URL, то  предполагается, что он обозначает пугь к файлу изображения.
В противном случае изображение загружается по указанному URL.
В представленных далее примерах изображения загружаются из файлов, находящихся в локальной файловой системе.
Следует также заметить,  что класс Image не является производным от класса Node.
Как пояснялось ранее, само изображение нельзя ввести в граф сцены.
Он позволяет отображать на месте метки текстовое сообщение, графику или и то и другое.
В приведенных ранее примерах на месте метки отображался только текст, но  не составляет особого труда воспроизвести там же изображение.
В приведенном ниже примере приложения демонстрируется метка,  содержащая графику.
Это может быть удобно в том случае, если изображение применяется в приложении лишь иногда.
Но если требуется воспроизвести только изображение,  это можно сделать и без метки, как пояснялось в предыдущем разделе.
Приводился пример применения экранной  кнопки с текстовой надписью.
И хотя такие кнопки широко распространены,  этим их применение не ограничивается, поскольку в них можно вводить изображение.
Можно также использовать только изображение.
Процедура ввода изображения в экранную кнопку практически ничем не отличается от его ввода в метку.
Затем оно вводится в кнопку.
В приведенном ниже примере в окне отображаются две  экранные кнопки, содержащие изображения.
Первый показывает песочные часы.
Второй показывает аналоговые часы.
При нажатии кнопки сообщается о выбранной разновидности часов.
Обратите внимание на то, что текстовая надпись отображается под изображением.
Он похож на экранную кнопку, но действует иначе, поскольку может находиться только в одном из двух состояний: нажатом и отпущенном.
Это означает,  что если нажать переключатель, он останется в нажатом состоянии, а не перейдет  после нажатия обратно в отпущенное состояние, как это обычно делает экранная  кнопка.
Если же нажать переключатель еще раз, он будет опущен.
Следовательно,  всякий раз, когда переключатель нажимается, он переходит в одно из двух своих  состояний.
Другой конструктор данного класса позволяет также ввести изображение в переключатель.
Когда кнопка нажата, эта опция выбирается.
Именно поэтому в прикладной  программе обычно требуется определить состояние переключателя.
Он возвращает логическое значение true, если кнопка нажата, и логическое значение false в противном случае.
Следует также иметь в виду, что переключатели можно объединять в группу.
В этом случае  одновременно может быть нажат только один  переключатель.
Процесс создания и применения  группы переключателей такой же, как и для кнопок-переключателей.
Он описывается в следующем разделе.
Переключатели-это группа взаимоисключающих кнопок, в которой одновременно может быть выбрана только одна кнопка.
Следовательно, кнопка-переключатель является особой формой переключателя.
Кнопки-переключатели должны быть вам уже  знакомы, поскольку они относятся к числу основных элементов управления GUI,  с помощью которых пользователь может выбрать один и только один вариант из  нескольких возможных.
Как только кнопки-переключатели будут введены в одну и ту же  группу, активизируется режим их взаимоисключающего выбора.
В общем, когда кнопки-переключатели объединяются в одну группу, одна из  них выбирается, как только их группа появляется в GUI.
Есть два способа, чтобы это сделать.
Иначе, он не выбран.
И хотя кнопка-переключатель выбирается, никакого события действия не генерируется.
Кнопки-переключатели можно применять самыми разными способами.
И простейшим из них, вероятно, является реагирование на событие действия, генерируемое при нажатии кнопки-переключателя.
Ниже приведена общая форма  данного метода.
В данном примере кнопки-переключатели предоставляют пользователю  возможность выбрать тип транспортного средства.
Как пояснялось ранее, кнопки-переключатели должны быть объединены в группу, чтобы активизировать режим их взаимоисключающего выбора.
Это приводит к тому, что эта кнопка будет выбрана и для нее будет сгенерировано событие действия.
В итоге  данная кнопка-переключатель инициализируется как выбираемая по умолчанию.
Когда в такой группе  происходит изменение, обработчик событий изменения может без особого труда  определить, какая именно кнопка-переключатель была выбрана, и на этом основании предпринять соответствующее действие.
По умолчанию создается горизонтальная линия.
Второй конструктор этого класса позволяет выбрать вертикальную разделяющую линию.
Флажки вам, без сомнения, хорошо известны, поскольку они широко применяются в GUI, но в JavaFX  флажок является несколько более сложным элементом управления, чем может  показаться на первый взгляд.
Двумя первыми являются установленное и сброшенное  состояния, как и следовало ожидать, поскольку это стандартное поведение флажка.
Третьим является так называемое неопределенное состояние флажка.
Оно, как  правило, обозначает незаданное или не соответствующее конкретной ситуации  состояние флажка.
Если требуется неопределенное состояние флажка, его придется разрешить явным образом.
Первым из них является  конструктор по умолчанию.
Второй конструктор позволяет указать символьную  строку, обозначающую флажок.
В приведенном ниже примере демонстрируется применение флажков.
Всякий  раз, когда флажок изменяет свое состояние, генерируется событие, обработка которого заключается в отображении нового (установленного или сброшенного) состояния флажка, а также списка всех установленных флажков.
Всякий раз, когда состояние флажка изменяется, формируется команда  действия.
Если же  требуется ввести неопределенное состояние  флажка, оно должно быть разрешено явным образом.
Иначе оно запрещается.
Когда неопределенное состояние флажка разрешено, пользователь может выбирать между установленным, сброшенным и неопределенным состоянием флажка.
Чтобы опробовать флажок с тремя состояниями на практике, можете немного видоизменить исходный код из предыдущего примера.
Внесите аналогичные изменения в обработчики событий от двух других флажков.
Представления списков - это элементы управления, отображающие списки, из которых можно выбрать один или несколько элементов.
Благодаря  тому что представления списков эффективно используют полезную площадь экрана, они служат широко распространенной альтернативой другим типам элементов  управления выбором.
Обычно это элементы типа String, хотя допускаются элементы других типов.
Второй  конструктор позволяет указать конкретный список элементов.
Следовательно, он  поддерживает стандартные методы обработки коллекций.
Но, изменив режим выбора, можно  разрешить выбор нескольких элементов из списка.
Ниже будет использована стандартная модель выбора одного элемента из списка.
Во-первых, проигнорировать события, генерируемые списком,  и просто получить результат выбора из списка, когда это потребуется в прикладной программе.
Во-вторых, отслеживать изменения в списке, зарегистрировав приемник событий изменения.
Это дает возможность оперативно реагировать на изменения, вносимые пользователем в выбор элементов из списка.
Именно этот способ и применяется далее.
Все сказанное выше о представлении списка демонстрируется в приведенном ниже примере.
В частности, в этом примере создается представление списка, отображающее различные виды транспортных средств, которые пользователь может  выбрать из списка.
Результат выбора отображается на месте метки.
Если режим одновременного выбора нескольких элементов из списка разре­ шен, то список выбранных элементов можно получить в двух формах: в виде самих  выбранных элементов или их индексов.
Здесь и далее будет использоваться список  выбранных элементов, но та же самая процедура распространяется и на список  индексов выбранных элементов.
В качестве эксперимента с одновременным выбором нескольких элементов из  списка попробуйте внести следующие изменения в исходный код из предыдущего  примера.
В комбинированном списке отображается лишь один выбираемый элемент, а остальные элементы  можно выбрать из дополнительно раскрываемого списка.
Пользователю можно предоставить возможность редактировать выбираемый элемент.
Зачастую это элементы типа String,   хотя допускаются и другие их типы.
Второй конструктор позволяет указать список элементов.
Он будет также генерировать событие изменения.
С другой стороны, события, наступающие в комбинированном списке,  можно проигнорировать и просто получить выбранный в настоящий момент элемент по мере надобности.
Это переделанный вариант предыдущего примера, в котором демонстрировалось применение представления списка.
Так,  если комбинированный список составлен  только из элементов типа String, то разрешить подобное редактирование совсем  не трудно.
Если параметр разрешение принимает логическое значение true ,  то редактирование разрешается.
Вам,  вероятно, будет интересно изучить их самостоятельно.
Но иногда пользователю требуется  предоставить возможность ввести избранную им символьную строку.
Для организации такого типа ввода пользовательских данных в JavaFX предусмотрено  несколько текстовых элементов управления.
Такой элемент управления позволяет ввести одну текстовую строку.
Первым из них является  конструктор по умолчанию, создающий пустое текстовое поле стандартных размеров.
А второй конструктор позволяет указать исходное содержимое текстового  поля.
Здесь и далее будет использоваться конструктор по умолчанию.
Хотя стандартных размеров текстового поля иногда оказывается достаточно,  зачастую его размеры требуется указывать явным образом.
Вы также можете выбрать часть текста под управлением программы.
Эта строка отображается светлым (например, светло-серым) цветом.
Зачастую это событие обрабатывается, но иногда в прикладной программе проще получить введенный текст по мере надобности, чем обрабатывать события действия от текстовых  полей.
Оба способа демонстрируются в приведенном ниже примере.
Создается текстовое поле, в котором вводится строка запроса на поиск информации.
Кроме того, текстовое поле снабжается наводящим сообщением.
Крупное изображение может не вписываться в разумные границы,  или длинный текст, который требуется отобразить в небольшом окне.
Для подобных случаев узлы графа сцены в JavaFX снабжаются полосами прокрутки.
От программиста больше не требуется дополнительных действий.
Первым из них является  конструктор по умолчанию.
Второй конструктор позволяет указать узел, который требуется прокручивать.
В итоге содержимое может быть прокручено, когда оно  отображается.
В итоге прокручиваемое содержимое может быть изменено  во время выполнения прикладной программы.
Как правило, размеры окна просмотра задаются явным образом, хотя по умолчанию выбираются стандартные размеры.
Окно просмотра представляет собой  просматриваемую область панели прокрутки.
Это та область, где отображается прокручиваемое  содержимое.
Таким образом, в окне просмотра отображается видимая часть содержимого.
Полосы прокрутки прокручивают содержимое через окно просмотра.
Таким образом, перемещая полосу прокрутки, вы меняете видимую часть содержимого.
Так, если компонент оказывается выше, чем окно просмотра, в последнее автоматически вводится вертикальная полоса прокрутки.
Если компонент полностью вписывается  в окно просмотра, то полосы прокрутки удаляются из окна просмотра.
По умолчанию функция отключена.
В другом случае, он отключен.
По умолчанию позиции полос прокругки  по горизонтали и по вертикали начинаются с нуля.
В частности, можно задать минимальные и максимальные позиции полос  прокрутки.
Вы также можете указать, когда и если полосы прокрутки отображаются, установив политику полосы прокрутки.
Обратите внимание, что он также включает панорамирование.
Он реализует иерархическое предстамение данных в древовидной форме.
В данном контексте термин иерархический означает, что одни элементы древовидной  структуры подчиняются другим.
Например, древовидная иерархия часто применяется для отображения содержимого файловой системы.
В этом случае отдельные  файлы подчиняются каталогу, который их содержит.
Это дает возможность представить иерархические данные в компактной, но развертываемой по мере надобности форме.
Таким образом, деревья достаточно просты  в применении, хотя и поддерживают довольно сложную иерархическую структуру.
Дерево начинается с одного корневого узла, обозначающего начало дерева.
Имеются два типа порожденных узлов: концевые узлы, называемые  иначе оконечными и не имеющие порожденных узлов, и узлы ветвления, образующие  корневые узлы поддерееъев.
Поддерево представляет собой обычное дерево, являющееся частью более крупного дерева.
Последовательность узлов, простирающаяся  от корневого узла к указанному узлу, называется путь.
Если полностью свернутое дерево может  быть достаточно маленьким, то его развернутая форма - достаточно крупной.
Зачастую  это значения типа String.
Для этого нужно сначала  создать корневой узел дерева.
Затем добавьте другие узлы к этому корню.
Добавляемые узлы могут быть концевыми узлами или поддеревьями.
Кроме того,  можно последовать по пути к элементу, перемещаясь по дереву в прямом или обратном направлении.
Дерева представляет иерархию пищевых продуктов.
В узлах  этого дерева находятся элементы типа символьных строк.
Корень дерева обозначен меткой Food.
Каждый раз, когда делается выбор, отображается имя элемента.
Кроме того, отображается путь от корня до элемента.
Во-первых, это порядок построения дерева.
Эти узлы образуют корни следующих поддеревьев: фруктов, овощей и орехов.
Далее к этим поддеревьям добавляются листья.
Но одно из них, поддерево фруктов, содержит другое поддерево - сортов яблок.
Суть здесь в том, что каждая  ветвь дерева приводит к листу или корню поддерева.
Как только все узлы дерева будут построены, корневые узлы каждого поддерева добавляются к корневому узду дерева.
Аналогичным образом любой порожденный  узел добавляется к своему родительскому узлу.
Второе, что нужно заметить в программе, - это то, как путь от корня до выбранного узла строится в обработчике событий change.
В данном примере это строковое значение с именем узла.
Если у этого узла отсутствует родительский узел, то переменной tmp присваивается пустое значение null.
В противном случае начинает выполняться цикл, в котором к содержимому переменной path добавляется  значение из каждого родительского узла (в данном случае имя этого узла).
Этот процесс продолжается до тех пор, пока не будет достигнут корневой узел дерева,  у которого отсутствует родительский узел.
Главное преимущество каркаса JavaFX заключается в том, что он позволяет изменять внешний вид элементов управления (или узлов графа сцены) с помощью  применяемых эффектов и/или выполняемых преобразований.
Эффекты и преобразования придают GUI сложный современный внешний вид, который уже привыкли ожидать пользователи.
Применяя эти эффекты, можно специально настроить внешний вид узлов в графе сцены.
Имеется целый ряд встроенных эффектов.
Разумеется,  одни  эффекты подходят отдельным элементам управления больше, чем другие.
Если же никакого  эффекта применять не требуется,  то в качестве этого параметра следует передать пустое значение null.
Как только это будет сделано, эффект станет  применяться к узлу всякий раз, когда он воспроизводится, при условии, что он  поддерживается исполняющей средой.
Однако процесс добавления эффекта, по сути, один и тот же, независимо от того, какой эффект вы выберете.
Степень свечения можно регулировать вручную.
В этом классе предоставляется целый ряд конструкторов.
По существу, радиус тени определяет ее размеры.
Каждый делает то, что подсказывает его название.
Над узлом можно выполнить несколько преобразований.
Например, можно вращать или  масштабировать его.
Чтобы выполнить над узлом преобразование, его можно, например, ввести  в список преобразований, поддерживаемых в данном узле.
Но намного удобнее  пользоваться списком преобразований, как будет продемонстрировано далее.
Аналогичным образом выполняются и остальные преобразования.
В классе Rotate поддерживается вращение узла вокруг указанной точки.
В этом классе определяется несколько конструкторов.
В классе Scale поддерживается масштабирование узла по указанному масштабному коэффициенту.
Класс Scale определяет несколько конструкторов.
Всякий раз, когда нажимается одна из этих кнопок, применяется соответствующий эффект или выполняется  над кнопками указанное преобразование над выбранной  кнопкой.
Анализируя исходный код JavaFX-приложения из данного примера, вы сможете сами убедиться, насколько просто осуществить специальную настройку GUI  своего приложения.
Поэкспериментируйте с JavaFX-приложением из данного  примера, опробуя другие виды преобразований или эффектов или применяя их  к другим типам узлов, кроме кнопок.
Он создает узел,  состоящий из текста.
Благодаря тому что это узел, текстом легко манипулировать  как единым целым, применяя к нему различные эффекты и выполняя над ним разнообразные преобразования.
Всплывающая подсказка - короткое сообщение, отображаемое при наведении курсора на элемент  управления.
В JavaFX совсем не трудно добавить всплывающую подсказку в любой  элемент управления.
Откровенно говоря, особых причин не пользоваться всплывающими подсказками не существует, принимая во внимание их преимущества  и простоту внедрения в GUI приложения.
Как только всплывающая подсказка будет задана, она автоматически отображается при наведении курсора на элемент  управления.
От вас больше ничего не требуется.
Любой узел в графе сцены,  в том числе и элемент управления, можно отключить под управлением прикладной программы.
Более того, надлежащая реализация меню считается  необходимой составляющей построения удачного GUI приложения.
В связи с тем  что меню играют главную роль во многих приложениях, в JavaFX обеспечивается  обширная поддержка меню.
И к счастью, эта поддержка меню в JavaFX не только мощная, но и рациональная.
Поэтому если вы уже знаете, как создаются меню в Swing, то научиться делать это в JavaFX вам будет нетрудно.
Но у обеих разновидностей меню имеется ряд отличий, поэтому очень важно не спешить с выводами  относительно системы меню в JavaFX.
Система меню в JavaFX поддерживает ряд основных элементов, включая следующие.
Строка меню, в которой находится главное меню приложения.
Стандартное меню, которое может содержать выбираемые пункты или другие меню, называемые подменю.
Всплывающее меню, которое обычно активизируется щелчком  правой кнопкой мыши.
Контекстные меню называют иначе всплывающими.
В системе меню JavaFX поддерживаются также оперативные клавиши, позволяющие выбирать пункты меню, не активизируя его, а также мнеминика, допускающая выбор пунктов с клавиатуры после раскрытия меню.
Вот краткий обзор того, как эти классы подходят друг другу.
Этот класс, грубо говоря, является контейнером для меню.
В дополнение к” стандартным " пунктам меню, вы также можете включить в меню пункты-переключатели и флажки.
Их работа аналогична флажку и переключателю управления.
Иначе они не могут быть включены в граф сцены.
Это позволяет создавать подменю, которые, по сути, являются меню внутри меню.
Вы увидите этот процесс в действии в следующих примерах.
При выборе пункта меню генерируется событие действия.
Текст, связанный с выделением, будет являться его именем.
Таким образом, при использовании одного обработчика событий действия для обработки всех вариантов меню можно определить, какой элемент был выбран, изучив его имя.
Конечно, вы также можете использовать отдельные анонимные внутренние классы или лямбда-выражения для обработки событий действия каждого элемента меню.
В этом случае выбор меню уже известен, и нет необходимости проверять название, чтобы определить, какой элемент был выбран.
В качестве альтернативы или дополнения к меню, которые спускаются из строки меню, вы также можете создать автономные контекстные меню, которые появляются при активации.
Контекстное меню часто активируется щелчком правой кнопки мыши, когда мышь находится над элементом управления.
Особенностью, связанной с меню, является панель инструментов.
Он создает автономный компонент, который часто используется для обеспечения быстрого доступа к функциям, содержащимся в меню приложения.
Например, панель инструментов может обеспечить быстрый доступ к командам форматирования, поддерживаемым текстовым процессором.
Они формируют минимальный набор классов, необходимых для построения главного меню приложения.
Это элемент управления, который обеспечивает главное меню приложения.
Таким образом, он может быть добавлен к графу сцены.
Поэтому изначально строка меню будет пустой, и вам нужно будет заполнить ее меню перед использованием.
Как правило, приложение имеет одну и только одну строку меню.
Он возвращает список меню, управляемых строкой меню.
Именно к этому списку вы добавите созданные вами меню.
Добавленные меню располагаются в строке слева направо в том порядке, в котором они были добавлены.
Индексация начинается с 0, причем 0-это самое левое меню.
В некоторых случаях может потребоваться удалить меню, которое больше не требуется.
Индексация начинается с нуля.
Это дает возможность создавать подменю, которые, по существу, являются одними меню, вложенными в другие.
Menu определяет три конструктора.
Во всех случаях меню остается пустым до тех пор, пока в него не будут добавлены пункты меню.
Наконец, вам не нужно давать меню имя, когда оно создается.
Каждое меню обслуживает список элементов меню, которые оно содержит.
Чтобы добавить элемент в меню, добавьте его в этот список.
Разделители помогают организовать длинные меню, позволяя вам группировать связанные элементы вместе.
Если значение disable равно false, то элемент включен.
Это меню определяется строкой меню, и это меню определяет все (или почти все) функциональные возможности приложения.
Как вы увидите, JavaFX упрощает процесс создания и управления главным меню.
Здесь вы увидите, как построить простое главное меню.
В последующих разделах будут показаны различные варианты.
Если вы уже знакомы с системой меню в Swing, вам будет полезно сравнить ее с системой меню в JavaFX.
Процесс создания главного меню состоит из нескольких стадий.
Затем создается каждое меню, располагаемое в строке меню.
Как только отдельные меню будуг созданы, они вводятся  в строку меню.
После этого сама строка меню вводится в граф сцены.
И наконец,  каждый пункт меню должен быть дополнен приемником действий, реагирующим  на событие действия, наступающее при выборе отдельного пункта из меню.
Процесс создания меню и управления ими станет понятнее, если продемонстрировать его на конкретном примере.
Ниже приведено приложение,  в котором создается простая строка меню, состоящая из трех меню.
Когда выбирается пункт меню, его наименование  отображается на месте метки.
Чтобы добавить пункты в меню, нужно составить прежде  список из его пунктов.
Следует также заметить, что для визуального отделения пункта Exit от остальных пунктов меню служит разделитель.
В целях демонстрации все  события выбора из меню обрабатываются одним обработчиком, но в реальном  приложении нередко оказывается проще указать отдельный обработчик событий  для каждого выбора из меню, используя анонимные внутренние классы или лямбда-выражения.
Они просто вызывают пункт меню.
Таким образом, данная комбинация клавиш будет действовать в Windows, MacOS и других операционных системах.
Мнемонику нетрудно указать как для пункта меню типа Menultem, так и для меню типа Menu.
Для этого достаточно предварить наименование меню или пункта меню знаком подчеркивания.
Если параметр включить принимает логическое значение true, то режим синтаксического анализа мнемоники включен.
В противном случае этот режим выключен.
Это дает возможность изменять изображение по ходу выполнения прикладной программы.
Эти отмечаемые пункты меню упрощают построение GUI, делая доступными из меню такие  функциональные возможности, для предоставления которых в противном случае  потребовались бы дополнительные автономные компоненты.
Кроме того, наличие флажков и кнопок-переключателей в меню иногда кажется вполне естественным для выбора конкретного ряда средств.
Но независимо от конкретных причин, применение флажков и кнопок-переключателей в меню довольно простое, как поясняется ниже.
Исходно флажок  находится в сброшенном состоянии.
В противном случае отметка пункта меню снимается.
Отмечаемые флажками пункты меню действуют аналогично автономным флажкам, они генерируют события действия при изменении их состояния.
Отмечаемые флажками пункты оказываются особенно полезными в тех меню, где  требуется отобразить состояние выбранных или невыбранных пунктов меню.
Первоначально этот пункт  меню не отмечается.
Как и автономные кнопки-переключатели, в меню кнопки-переключатели должны  быть объединены в группу, чтобы они действовали в режиме взаимоисключающего выбора.
Помимо дополнительных возможностей флажков и кнопок-переключателей, отмечаемые пункты меню ничем не отличаются от обычных пунктов меню.
Как правило, контекстное меню активизируется щелчком  правой кнопкой мыши на элементе управления.
В общем, контекстные меню создаются таким же образом, как и обычные меню.
Сначала создаются отдельные пункты, а затем они вводятся в меню.
Обработка  результатов выбора пунктов контекстного меню выполняется тем же самым способом: приемом событий действия.
Главное отличие контекстные меню от обычных - это процесс их активизации.
Связать контекстное меню с элементом управления не составляет особого труда.
Если теперь щелкнуть правой кнопкой мыши на данном текстовом поле, всплывет контекстное меню.
Затем он создает экземпляр ContextMenu, называемый editMenu, который содержит элементы.
Здесь узел - это элемент, с которым связано контекстное меню.
Как правило, передаются координаты точки, в которой был произведен щелчок  правой кнопкой мыши.
Все сказанное выше можно применить на практике, введя контекстное меню  в корневой узел графа сцены.
Если после этого щелкнуть правой кнопкой мыши  на любом месте в сцене, появится контекстное меню.
Такая панель состоит из ряда кнопок,  предоставляющих пользователю возможность немедленного доступа  к различным параметрам и режимам работы программы.
Например, панель инструментов может содержать кнопки для выбора параметров шрифтового оформления текста, в том числе полужирного или наклонного начертания, выделения  или подчеркивания текста.
Эти параметры можно выбрать, не раскрывая меню.
Как правило, кнопки на панели инструментов обозначены значками, а не текстовыми надписями, хотя допускается и то и другое.
Кроме того, кнопки на панели инструментов нередко снабжаются всплывающим подсказками.
B JavaFX панели инструментов являются экземплярами класса ToolBar.
Первый конструктор создает пустую горизонтальную панель.
Второй конструктор создает горизонтальную панель, содержащую указанные узлы, которые обычно представлены в некоторой форме кнопки.
Как только панель инструментов  будет создана, ее следует ввести в граф сцены.
Так, если применяется граничная  компоновка, то панель инструментов можно расположить в нижней области этой  компоновки.
Конечно допускается и другое ее расположение.
В частности, панель инструментов можно расположить непосредственно под строкой меню или вдоль  одной из боковых сторон окна.
Кроме того, кнопки на панели  инструментов снабжаются всплывающими подсказками.
Как пояснялось в предыдущей главе, всплывающая подсказка представляет собой небольшое сообщение,  описывающее связанный с ней элемент управления.
Она автоматически всплывает на некоторое время при наведении курсора мыши на элемент управления.
Всплывающие подсказки особенно удобны для элементов управления, представленных только  значками на панели инструментов, поскольку не всегда удается оформить такие  значки, которые интуитивно понятны всем пользователям.
Во-первых, создайте элементы панели инструментов.
Сначала в нем создаются три кнопки для выбора режимов отладки на панели инструментов.
Обратите внимание, что у каждого из них есть изображение, связанное с ним.
Прежде чем завершить  эту главу, целесообразно составить окончательный вариант данного приложения  с учетом всех изменений и дополнений.
Это позволит не только избежать недоразумений относительно согласованности отдельных частей программы, но и получить рабочее приложение для демонстрации меню и дальнейшего экспериментирования с ними.
Ради большей ясности исходный код этого приложения был реорганизован таким образом, чтобы создавать разные меню и панель инструментов, используя отдельные методы.
В нем также переопределяются средства платформы Java.
В предыдущих трех главах были представлены некоторые из его основных особенностей, но многое еще предстоит исследовать.
К числу основных средств JavaFX относится  ряд дополнительных элементов управления, включая ползунки, автономные полосы  прокругки и таблицы.
Эти компоненты можно создавать самостоятельно, а также приобретать в готовом виде у сторонних производителей.
В распоряжении разработчиков оборудования вычислительных систем имеются разнообразные компоненты, из которых можно построить вычислительную систему.
Резисторы, конденсаторы и катушки индуктивности служат примерами простых стандартных блоков.
Интегральные схемы предлагают еще  больше функциональных возможностей.
Каждый из этих компонентов можно использовать многократно.
Их не нужно компоновать заново всякий раз, когда требуется создать новую систему.
Кроме того, одни и те же компоненты можно использовать в разнотипных схемах.
И все это возможно потому, что поведение подобных компонентов заранее известно и хорошо документировано.
И в отрасли разработки программного обеспечения предпринимались попытки воспользоваться преимуществами многократного использования компонентов  и их способностью к взаимодействию.
Для этого необходимо было разработать  такую архитектуру компонентов, которая позволила бы составлять программы из  стандартных блоков, в том числе и предлагаемых сторонними производителями.
Кроме того, разработчик должен был иметь возможность выбрать компонент,  разобраться в его функциях и внедрить его в приложение.
После выхода новой версии компонента нужно было обеспечить простоту внедрения его функциональных возможностей в уже существующий прикладной код.
Они  могут выполнять простую функцию, например получать стоимость товарно-материальных запасов, а могут реализовать и более сложную функцию, в частности прогнозировать котировки акций на фондовой бирже.
Одним из примеров таких компонентов служит экранная кнопка в GUI.
Примером таких компонентов служит  программное обеспечение для декодирования потока мультимедийной информации в реальном времени.
Вспомогательное  программное обеспечение требуется только для установки параметров  на стадии разработки компонента.
А включать его в исполняющую среду не нужно.
Первый способ состоит в том, чтобы использовать простые условные обозначения.
Оба способа рассматриваются в последующих разделах.
Значения,  присваиваемые свойствам, определяют поведение и внешний вид компонента.
Значение свойства устанавливается методом записи.
Значение свойства получается методом получения.
Имеются две разновидности свойств: простые и индексированные.
А защищенные и закрытые методы остаются недоступными.
Реализуя эти методы, разработчик может точ­ но определить, что именно доступно пользователю,  не прибегая к самоанализу,  выполняемому на основе шаблонов проектирования.
Если не переопределить такой метод, то будет выполнен самоанализ из шаблона проектирования.
Это извещение о событии посылается другим объектам, предварительно зарегистрировавшимся на получение  таких уведомлений.
Автоматическую сериализацию можно также наследовать.
При автоматической сериализации можно выборочно отключить сохранение  отдельного поля с помощью ключевого слова transient.
В противном случае контейнеры не  смогут сохранить конфигурацию компонентов.
Настройщик может обеспечивать пошаговое  руководство всем процессом, выполняя его указания, можно добиться применения компонента в определенном контексте.
Может быть использован для записи информации в поток.
Каждый из них кратко описан здесь.
Предоставляет ряд методов для управления свойствами и их описаниями.
Он  предоставляет ряд методов для доступа к методам, предназначенным для ввода  или удаления приемников событий или управления иным способом событиями  в компонентах Java Beans.
Данный пример состоит из трех классов.
Он выбирает произвольный цвет и окрашивает им компонент.
В данном случае пользователю  доступно только свойство rectangular.
На этот раз будет выведено больше свойств.
Сервлетами называют небольшие программы, которые выполняются на стороне сервера веб-подключения.
Аплеты динамически расширяют функциональные возможности веб-браузера, а сервлеты - возможности веб-сервера.
Тема сервлетов довольно обширна, и ее невозможно  рассмотреть полностью в рамках одной главы.
Поэтому в этой главе будут представлены основные принципы, интерфейсы и классы, а также некоторые примеры.
Чтобы стали понятнее преимушества сервлетов, следует дать хотя бы общее  представление о взаимодействии веб-браузеров и сервлетов для предоставления  содержимого пользователю.
Рассмотрим обработку запроса статической веб­страницы.
Пользователь вводит в поле адреса браузера URL.
Браузер формирует запрос по сетевому протоколу НТТР, направляя его соответствующему веб-серверу.
Веб-сервер сопоставляет  этот запрос с конкретным файлом.
Возвращая файл браузеру в виде ответа, посылаемого по сетевому протоколу НТТР.
В этом ответе НТТР-заголовок обозначает тип содержимого.
Для этой цели служит стандарт MIME (многоцелевые расширения электронной почты).
Например,  обычный текст в формате ASCII имеет тип MIME, обозначаемый как text/plain.
Исходный код HTML  имеет тип MIME, обозначаемый как text/html.
А теперь рассмотрим динамическое содержимое.
Допустим, база данных применяется в интернет-магазине для хранения сведений о его коммерческой деятельности.
В базе данных могут храниться продаваемые товары, прейскуранты, сведения  о наличии товара, заказах и т.п.
Владелец этого интернет-магазина решил сделать  эту информацию доступной покупателям через веб-страницы.
Содержимое этих  веб-страниц должно создаваться динамически, чтобы отражать самые последние  сведения, хранящиеся в базе данных.
В первые годы существования Веб-сети сервер мог динамически формировать  страницу, создавая отдельный процесс для обработки каждого запроса клиента.
Чтобы получить необходимую информацию, процесс мог устанавливать соединение с одной или несколькими базами данных.
Связь с сервером осуществлялась  через интерфейс Common Gateway Interface (CGI).
Интерфейс CGI позволял отдельным процессам вводить данные из  HTTP-запроса  и выводить их в HTTP-ответ.
Для написания CGI-программ применялись разные  языки программирования.
Он был неэффективным с точки зрения ресурсов ЦП и оперативной  памяти, потребляемых для создания отдельного процесса по каждому запросу клиента.
Также он требовал много ресурсов, чтобы устанавливать  и разрывать соединения с базой данных по каждому запросу клиента.
Кроме того, CGI­ программы зависели от конкретной платформы.
Потому для преодоления подобных недостатков бьши внедрены другие методики.
К их числу относят сервлеты.
По сравнению с интерфейсом CGI сервлеты обладают рядом преимуществ.
Во­первых, их производительность заметно выше.
Сервлеты выполняются в адресном  пространстве веб-сервера.
Чтобы выполнить обработку каждого запроса клиента, не  обязательно создавать отдельный процесс.
Во-вторых, сервлеты не зависят от конкретной платформы, поскольку они разрабатываются нa Java.
В-третьих, диспетчер  безопасности Java на сервере накладывает ряд ограничений для защиты ресурсов  на серверной машине.
И наконец, для сервлета доступны абсолютно все функциональные возможности библиотек классов Java.
Сервлет может связываться с аплетами, базой данных и другим программным обеспечением о вызова методов,  рассматривавшиеся ранее в данной книге.
Они реализуются каждым сервлетом и в нужный момент вызываются сервером.
Рассмотрим обычный сценарий взаимодействия с пользователем, который поможет лучше понять, когда именно происходит вызов этих методов.
Затем браузер генерирует HTTP-запрос для этого URL-адреса.
HTTP-запрос, посылается соответствующему серверу.
Затем, этот HTTP-запрос получает веб-сервер.
Сервер принимает запрос и сопоставляет его с конкретным сервлетом.
Обнаруженный сервлет динамически загружается в адресное пространство сервера.
Этот метод вызывается только  в том случае, если сервлет впервые загружается в оперативную память.
Сервлету можно передавать параметры инициализации, поэтому он допускает самонастройку.
Этот метод вызывается для обработки HTTP-запроса.
Вы увидите, что сервлет может считывать данные, предоставленные в HTTP-запросе.
Сервлет может сформировать HTTP­ответ клиенту.
Сервлет остается в адресном пространстве сервера и доступен  для обработки любых других HTTP-запросов, получаемых от клиентов.
И наконец, сервер может принять решение выгрузить сервлет из оперативной  памяти.
Для принятия такого решения на каждом сервере применяются разные алгоритмы.
Важные данные могут быть сохранены в постоянном хранилище.
Оперативная память, выделяемая для сервлета и его  объектов, может быть впоследствии утилизирована в процессе "сборки мусора".
В разных IDE разработка и развертывание сервлетов имеет свои отличия, и поэтому здесь просто невозможно рассмотреть все эти отличия.
Кроме того, многие  читатели, скорее всего, будут пользоваться инструментальными средствами командной строки , а не IDE.
Поэтому, если вы пользуетесь IDE, за справкой о разработке и развертывании сервлетов обращайтесь к документации на эту IDE.
А все приведенные далее пояснения подразумевают, что для разработки сервлетов  применяются только инструментальные средства командной строки.
Таким образом, они подойдут практически для любого читателя.
Он также широко доступен в различных средах программирования.
Кроме того, не придется загружать и устанавливать IDE только для того, чтобы экспериментировать с сервлетами,  поскольку для этого  достаточно инструментальных средств командной строки.
Немного отличаться будет лишь механизм подготовки сервлета к тестированию.
Если вы пользуетесь IDE и другим контейнером сервлетов или сервером  приложений,  обратитесь к документации на свою среду.
Этот пакет содержит классы и интерфейсы, требующиеся для создания сервлетов.
Мы еще вернемся к ним далее в этой главе.
Этот метод обрабатывает запросы от клиента.
Это позволяет сервлету считывать данные, предоставляемые по запросу клиента.
Это позволяет сервлету сформировать ответ для клиента.
Он обозначает, что браузер должен интерпретировать содержимое как исходный код HTML-разметки.
Все, что направляется в поток вывода, посылается клиенту как часть HTTP-ответа.
В окне браузера должны появиться данные, выводимые сервлетом.
Рассматриваемые в этой главе классы и интерфейсы, требующиеся для разработки сервлетов, содержатся в двух пакетах.
Они образуют интерфейс Servlet API.
Следует, однако, иметь в виду, что эти  пакеты не относятся к основным пакетам Java core.
Следовательно, они не входят в состав версии Java SE.
Также они предоставлены Java EE.
Прикладной программный интерфейс Servlet API по-прежнему находится  на стадии разработки и усовершенствования.
Но  поскольку в Java все постоянно меняется, то поинтересуйтесь, не появились ли  какие-нибудь дополнения или видоизменения данной спецификации.
В этой главе  обсуждается ядро прикладного программного интерфейса Servlet API, которое доступно большинству читателей и поддерживается во всех современных версиях  спецификации сервлетов.
В таблице, представленной ниже, собраны все ключевые интерфейсы, предоставленные в этом пакете.
Самым главным из них является  интерфейс Servlet.
Все сервлеты должны реализовывать этот интерфейс или расширять класс, реализующий этот интерфейс.
Давайте подробнее исследуем эти интерфейсы и классы.
Также предусмотрен метод, позволяющий сервлету получать любые параметры инициализации.
Они вызываются сервером.
Если длину запроса нельзя определить, возвращается значение -1.
Если тип запроса нельзя определить, возвращается пустое значение null.
Также метод для записи символьной строки в журнал сервера.
В этом классе  определяется конструктор по умолчанию, а также метод для чтения байтов из потока ввода.
В дополнение к методам ввода, унаследованным от InputStream, предусмотрен метод считывания байтов из потока.
Этот метод возвращает фактическое количество прочитанных байтов или значение -1 ,  если будет  достигнуто условие окончания потока ввода.
Он реализуется контейнером сервлетов и предоставляет поток вывода, который разработчик  сервлета может применять для записи данных в ответ клиенту.
Это исключение извещает  о том, что сервлет недоступен.
В интерфейс ServletRequest  входят методы, позволяющие вводить имена  и значения параметров, включаемых в запрос клиента.
В приведенном далее примере разрабатывается сервлет, демонстрирующий их применение.
В этом  коде определяется таблица, состоящая из двух меток и двух текстовых полей.
Одна  из меток называется Employee, другая - Phone.
Имеется  также кнопка подтверждения.
Обратите внимание,что параметр action тега form указывает URL-адрес.
URL-адрес определяет сервлет для обработки запроса HTTP POST.
Их обработка  осуществляется в цикле.
Как видите, для клиента выводится имя параметра и его  значение.
Воспроизведите веб-страницу в окне браузера.
Введите в текстовых полях фамилию служащего и номер его телефона.
Передайте веб-страницу клиенту.
Таким образом, в окне браузера будет воспроизведен ответ, динамически сформированный сервлетом.
Как станет ясно в дальнейшем, его функциональные возможности упрощают создание сервлетов, обрабатывающих запросы и ответы по сетевому протоколу НТТР.
Позволяет сервлетам записывать данные в HTTP-запрос.
Позволяет читать и записывать данные о сеансе связи.
В таблице ниже представлены основные классы, использующиеся в этой главе.
Наиболее важным из них является класс HttpServlet.
Разработчики сервлетов  обычно расширяют этот класс для обработки НТТР-запросов.
Определено несколько констант.
Они соответствуют различным кодам состояния, которые могут быть назначены ответу HTTP.
Интерфейс HttpSession позволяет сервлету читать и записывать информацию о состоянии, которая связана с текущим HTTP-сеансом.
Возвращает метод для HTTP-запроса.
Возвращает любые сведения о пути, который следует  после пути к сервлету и перед строкой запроса в URL.
Возвращает любые сведения о пути, который следует  после пути к сервлету и перед строкой запроса в URL  после ее преобразования в настоящий путь. 
Возвращает любую строку запроса в URL.
Возвращает имя пользователя, который составил данный запрос.
Возвращает идентификатор сеанса связи.
Возвращает URI.
Возвращает URL.
Возвращает часть URL, которая обозначает сервлет.
Возвращает сеанс связи по данному запросу.
Если сеанс  связи не существует, он создается, а затем возвращается.
В противном случае, возвращает текущий сеанс для этого запроса.
Иначе, возвращает логическое зачение false.
Cookie-файл хранится на стороне клиента и содержит данные состояния.
Пользоваться cookie-файлами удобно для отслеживания активности пользователей.
Допустим, пользователь посещает интернет-магазин.
В cookie-файле можно сохранить имя пользователя, адрес и прочие сведения о нем.
В этом случае пользователю не нужно вводить эти данные всякий раз,  когда он посещает этот интернет-магазин.
Данные из этого  cookie-файла  затем включаются в заголовок НТТР-ответа, который отправляется браузеру.
Имена и значения из cookie-файлов хранятся на машине пользователя.
Если так, то возвращает измененную версию url.
Иначе, вернуть url.
Все URL, сгенерированные сервлетом долэны быть обработаны этим методом.
Если так, то вернет измененную версию url.
В противном случае, вернет url.
Если дата окончания срока действия cookie-файла не назначена явным  образом, cookie-файл удаляется по завершении текущего сеанса связи с браузером.
Домен и путь к cookie-файлу определяют, когда он будет включен в заголовок  НТТР-запроса.
Если пользователь вводит URL, где домен и путь совпадают с этими  значениями, то cookie-файл-файл предоставляется веб-серверу.
В противном случае - не  предоставляется.
У класса Cookie имеется единственный конструктор.
Это часто используется при разработке сервлетов, которые принимают и обрабатывают HTTP-запросы.
Иначе - возвращает значение false.
Этот срок определяется количеством  секунд, по истечении которых cookie-файл удаляется.
Разработчики сервлетов обычно переопределяют  один из этих методов.
Привести здесь полное  описание различных типов НТТР-запросов не представляется возможным.
Но чаще всего при обращении с заполняемыми формами применяются НТТР-запросы типа GET и POST.
Следовательно, этот раздел показывает примеры таких случаев.
Затем скопируйте его в соответствующий  каталог и обновите файл web.
Выведите веб-страницу в окне браузера.
Выберите нужный цвет.
Передайте форму, заполненную на веб-странице.
После этого браузер выведет результат, динамически сформированный сервлетом.
Следует также иметь в виду, что параметры для НТТР-запроса типа GET  включены как составная часть в URL, посылаемый веб-серверу.
Допустим, пользователь выбрал красный цвет и передал заполненную форму.
Этот сервлет вызывается при передаче формы, заполненной  на неб-странице.
Данный пример состоит из двух файлов.
После этого формируется ответ на данный запрос.
Чтобы проверить его, выполните те же действия, что и в предыдущем разделе.
Имена и значения параметров отправляются в теле HTTP-запроса.
Этот сервлет вызывается при передаче формы.
Эта страница содержит текстовое поле для ввода значения.
А также кнопку  для передачи заполненной формы.
Он получает значение параметра по имени data.
И  наконец,  браузер получает ответное сообщение.
Имена и значения этих cookie-файлов включаются в НТТР-ответ.
После этого выполните следующие действия, чтобы проверить данный пример.
Передайте форму, заполненную на веб-странице.
Выполнив эти действия, вы увидите, что в окне браузера отображается ответное сообщение.